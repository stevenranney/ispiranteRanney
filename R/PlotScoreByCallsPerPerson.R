
PlotScoreByCallsPerPerson <- structure(
function # Create a plot of the score by calls/person

  ##############################################################################
  # File:  PlotScoreByCallsPerPerson.R
  ##author<<  Steven H. Ranney
  ## Contact: \email{Steven.Ranney@gmail.com}
  # Created: 12/30/14  
  # Last Edited: 12/30/14 by SHR
  ##description<< This function plots the satisfaction score and produces a plot 
  ## of those values as a function of calls/person.  Satisfaction scores are averaged
  ## over the course of a day and the calls/person are calculated over that same 
  ## day.
  #
  # TODO: add RData for example
  # TODO: add testing section
  ###############################################################################

  (dF, ##<< The dataFrame for which to convert \code{satisfaction_score} into a 
      ## number.
  ... ##<< Arguments to be passed to other functions.  Specifically, this can take 
      ## the form of identifying which \code{date} value is of interest.  For example
      ## the sample datasets provided all had either at least \code{assigned_at} 
      ## or \code{created_at} values.  The \code{\link{AssignDateAndDay}} can used
      ## either of these values as the date of interest. 
  ){
  
  ##details<< This function calls the \code{\link{ConvertSatisfactionScoreToNumber}} 
  ## function to assign the \code{day} values used.  
  dF <- ConvertSatisfactionScoreToNumber(dF)
 
  dF <- AssignDateAndDay(dF, ...)

  #Eliminate rows where there is no date assigned
  dF <- dF[which(!is.na(dF$assignedDate)), ]
    
  #aggregate call volume by date
  volData <- aggregate(dF$dayOfWeek, by = list(dF$assignedDate), length)
  names(volData) <- c("assignedDate", "totalCalls")
  volData <- volData[order(volData$assignedDate), ]
  
  nameData <- aggregate(dF$assignee_name, by = list(dF$assignedDate), unique)
  names(nameData) <- c("assignedDate", "assignees")
 
  #Function to calculate the number of assignees on each date
  calcLen <- function(nameData){
    length(unlist(nameData$assignees))
    }
  
  nameData$numAssignees <- apply(nameData, 1, calcLen)  
 
  tmp <- merge(volData, nameData, by = "assignedDate", all = T)
  tmp$callsPerPerson <- tmp$totalCalls/tmp$numAssignees
  
  #aggregate scores by Date
  scoreData <- aggregate(dF$scoreNumber, by = list(dF$assignedDate), mean, na.rm = T)
  names(scoreData) <- c("assignedDate", "meanScore")
  scoreData <- scoreData[order(scoreData$assignedDate), ]
  
  allData <- cbind(tmp, scoreData)

  if(length(which(is.na(dF$scoreNumber))) == nrow(dF)){
    stop("There is no satisfaction data in this data frame.")
    } else {
    
  ##details<< Plots are generated by the function \code{\link{ggplot}}
  
  ##details<< This function uses a linear model to evaluate the relationship between
  ## satisfaction score and the number of calls per person.  If the red line 
  ## (the result of the \code{\link{lm}} in the produced plot trends down, then 
  ## the number of calls per person has a negative affect on satisfaction score.  
  ## If the red line is parallel or very near to parallel, then there is no 
  ## relationship between satisfaction score and the number of calls per person.
  
  xlabel <- "Calls per Person"  
  ylabel <- "Satisfaction score (numeric)"
  
  #Create a linear model of score as a function of wait time (hours)
  lmMod <- lm(allData$meanScore~allData$callsPerPerson) 

  g <- ggplot(allData, aes(x = callsPerPerson, y = meanScore))

    p1 <- g + geom_point() + labs(ylab(ylabel)) + labs(xlab(xlabel)) +  
              geom_abline(intercept=lmMod$coefficients[1], slope=lmMod$coefficients[2], 
                          colour = "red", size = 1.01)
    
    } # end else
    return(p1)    

})   
